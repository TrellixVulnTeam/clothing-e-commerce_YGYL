{"ast":null,"code":"import { createSelector } from \"reselect\";\nimport memoize from \"lodash.memoize\"; //because the url parameter is a string and the id is a number, a map was created to match both\n//but after transforming the data in objects instead of arrays, it solved the problem so it is not needed anymore\n\n/*const COLLECTION_ID_MAP = {\n  hats: 1,\n  sneakers: 2,\n  jackets: 3,\n  womens: 4,\n  mens: 5,\n}; */\n\nconst selectShop = state => state.shop;\n\nexport const selectCollections = createSelector([selectShop], shop => shop.collections);\n/*By wrapping this function with memoize, we're saying that whenever this function \ngets called and receives collectionUrlParam, I want to memoize the return of this \nfunction (in this case we return a selector). If this function gets called again with\nthe same collectionUrlParam, don't rerun this function because we'll return the same \nvalue as last time, which we've memoized so just return the selector that's been stored. */\n\nexport const selectCollection = memoize(collectionUrlParam => createSelector([selectCollections], collections => collections[collectionUrlParam]\n/*collections.find( //find collection.id matching the url parameter from the collection_id_map **removed to increase performance, find() can get slow if the data is too big\n    (collection) => collection.id === COLLECTION_ID_MAP[collectionUrlParam]\n  )*/\n));\nexport const selectCollectionsForPreview = createSelector([selectCollection], //get the values from the object in an specific key\ncollections => Object.keys(collections).map(key => collections[key]));","map":{"version":3,"sources":["/Users/patry/react_projects/clothing-e-commerce/clothing-e-commerce/src/redux/shop/shop.selectors.js"],"names":["createSelector","memoize","selectShop","state","shop","selectCollections","collections","selectCollection","collectionUrlParam","selectCollectionsForPreview","Object","keys","map","key"],"mappings":"AAAA,SAASA,cAAT,QAA+B,UAA/B;AACA,OAAOC,OAAP,MAAoB,gBAApB,C,CAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,UAAU,GAAIC,KAAD,IAAWA,KAAK,CAACC,IAApC;;AAEA,OAAO,MAAMC,iBAAiB,GAAGL,cAAc,CAC7C,CAACE,UAAD,CAD6C,EAE5CE,IAAD,IAAUA,IAAI,CAACE,WAF8B,CAAxC;AAKP;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,gBAAgB,GAAGN,OAAO,CAAEO,kBAAD,IACtCR,cAAc,CAAC,CAACK,iBAAD,CAAD,EAAuBC,WAAD,IAClCA,WAAW,CAACE,kBAAD;AACb;AACF;AACA;AAJgB,CADuB,CAAhC;AASP,OAAO,MAAMC,2BAA2B,GAAGT,cAAc,CACrD,CAACO,gBAAD,CADqD,EAErD;AACAD,WAAW,IAAII,MAAM,CAACC,IAAP,CAAYL,WAAZ,EAAyBM,GAAzB,CAA6BC,GAAG,IAAIP,WAAW,CAACO,GAAD,CAA/C,CAHsC,CAAlD","sourcesContent":["import { createSelector } from \"reselect\";\nimport memoize from \"lodash.memoize\";\n\n//because the url parameter is a string and the id is a number, a map was created to match both\n//but after transforming the data in objects instead of arrays, it solved the problem so it is not needed anymore\n/*const COLLECTION_ID_MAP = {\n  hats: 1,\n  sneakers: 2,\n  jackets: 3,\n  womens: 4,\n  mens: 5,\n}; */\n\nconst selectShop = (state) => state.shop;\n\nexport const selectCollections = createSelector(\n  [selectShop],\n  (shop) => shop.collections\n);\n\n/*By wrapping this function with memoize, we're saying that whenever this function \ngets called and receives collectionUrlParam, I want to memoize the return of this \nfunction (in this case we return a selector). If this function gets called again with\nthe same collectionUrlParam, don't rerun this function because we'll return the same \nvalue as last time, which we've memoized so just return the selector that's been stored. */\nexport const selectCollection = memoize((collectionUrlParam) =>\n  createSelector([selectCollections], (collections) =>\n    collections[collectionUrlParam]    \n  /*collections.find( //find collection.id matching the url parameter from the collection_id_map **removed to increase performance, find() can get slow if the data is too big\n      (collection) => collection.id === COLLECTION_ID_MAP[collectionUrlParam]\n    )*/\n  )\n);\n\nexport const selectCollectionsForPreview = createSelector(\n    [selectCollection],\n    //get the values from the object in an specific key\n    collections => Object.keys(collections).map(key => collections[key]) \n);\n"]},"metadata":{},"sourceType":"module"}